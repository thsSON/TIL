# **99클럽 코테 스터디 10일차 TIL**

### **오늘의 학습 키워드**

- 시간 초과(TLE) 원인 분석 및 개선
- 해시맵을 활용한 중복 제거 및 카운팅
- 재귀 → DP 최적화 사고 전환
- 부분 수열 문제 유형 이해

---

### **공부한 내용 본인의 언어로 정리하기**

### 🔹 **문제 1 - [백준 2358: 평행선](https://www.acmicpc.net/problem/2358)**

처음에는 중복을 제거하면서 같은 x좌표를 가진 점들이 있는지 확인하려고 다음과 같이 비효율적인 중첩 반복문을 사용했다:

```python
python
복사편집
for i in range(n):
    for j in range(i+1, n):
        if points[i][0] == points[j][0] and not X.count(points[i][0]):
            cnt += 1
            X.append(points[i][0])

```

당연히 시간 초과가 발생했다.

해시로 풀어야 할 것 같다는 생각은 들었지만, **정확히 어떤 방식으로 key-value를 구성하고 중복을 관리해야 할지 막연했다.**

결국 딕셔너리를 활용해 x좌표와 y좌표별로 등장 여부를 관리하고, 두 번 이상 등장한 좌표만 카운팅해서 해결할 수 있었다.

**→ 해시 자료구조에 익숙하지 않다는 걸 느꼈고, 다시 정리하고 복습해야겠다고 다짐했다.**

---

### 🔹 **문제 2 - [백준 14495: 피보나치 비스무리한 수열](https://www.acmicpc.net/problem/14495)**

처음에는 **재귀 방식**으로 단순하게 구현했지만, 역시 예상대로 시간 초과가 발생했다.

예전에 본 적 있는 문제라, **중간 결과를 저장해두는 방식으로 반복문을 써서 푸는 게 최적화에 도움이 된다**는 걸 어렴풋이 기억했다.

결국 `dp[i] = dp[i-1] + dp[i-3]` 형태로 점화식을 만들고, 배열에 값을 저장해가며 반복문으로 해결했다.

**→ 구현 방법은 기억이 안 나도, 전체 흐름은 기억하고 있다는 게 중요한 점이었다.**

**→ 비슷한 문제를 반복해서 풀어보는 게 구현 능력 향상에 도움이 될 것 같다고 느꼈다.**

---

## 코드 :

```python
# Baekjoon_2358

n = int(input().rstrip())
x_dict = {}
y_dict = {}
cnt = 0


for _ in range(n):
    x, y = map(int, input().split())

    if x in x_dict:
        x_dict[x] = True
    else:
        x_dict[x] = False

    if y in y_dict:
        y_dict[y] = True
    else:
        y_dict[y] = False        

for val in x_dict.values():
    if val:
        cnt += 1

for val in y_dict.values():
    if val:
        cnt += 1

print(cnt)

###########################################################

# Baekjoon_14495

n = int(sys.stdin.readline())

dp = [0] * n
dp[:3] = [1, 1, 1]

for i in range(3, n):
    dp[i] = dp[i - 1] + dp[i - 3]

print(dp[n - 1])


```

---

### **오늘의 회고**

- **어떤 문제가 있었고, 나는 어떤 시도를 했는지?**
    - 평행선 문제에서는 이중 for문 + `list.count()`의 조합으로 비효율적인 풀이를 처음 시도
    - 피보나치 문제에서는 무작정 재귀로 접근하다가 시간 초과 발생
    
- **어떻게 해결했는지?**
    - 해시맵을 활용해 x/y좌표별 등장 여부를 Boolean 값으로 관리하여 중복 제거
    - 반복문과 배열을 활용한 DP 방식으로 점화식 기반 풀이 진행
    
- **무엇을 새롭게 알았는지?**
    - **비효율적인 탐색 방식은 아주 작은 입력에도 치명적**이라는 것을 다시 체감
    - 해시를 쓸 수 있는 상황에서, 어떤 기준으로 key를 잡을지 명확히 설정하는 게 중요
    - **DP 문제는 이전에 본 패턴이라도 손으로 직접 몇 번 다시 구현해보는 게 중요**
    
- **내일 학습할 것은 무엇인지?**
    - **해시 자료구조 개념 복습** (충돌 처리, 성능 등 포함)
    - 피보나치/DP 계열 문제 몇 개 더 풀어보기
    - 1~10일차 TIL을 돌아보며 다시 복습하고 놓친 개념은 없는지 체크하기